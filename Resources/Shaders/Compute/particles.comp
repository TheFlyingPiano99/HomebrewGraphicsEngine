#version 430 compatibility
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

/*
layout( std140, binding = 4 ) buffer Pos
{
    vec4 Positions[]; // array of structures
};


layout( std140, binding = 5 ) buffer Vel
{
    vec4 Velocities[]; // array of structures
};

layout( std140, binding = 6 ) buffer Col
{
    vec4 Colors[]; // array of structures
};

layout(local_size_variable) in;

const vec3 G = vec3(0.0, -9.8, 0.0);
const float DT = 0.1;

const vec4 SPHERE = vec4(100, 800, 0, 600);


vec3 Bounce( vec3 vin, vec3 n )
{
    vec3 vout = reflect( vin, n );
    return vout;
}


vec3 BounceSphere( vec3 p, vec3 v, vec4 s )
{
    vec3 n = normalize( p - s.xyz );
    return B() ounce(v, n);
}


bool IsInsideSphere( vec3 p, vec4 s )
{
    float r = length( p - s.xyz );
    return ( r < s.w );
}


uint gid = gl_GlobalInvocationID.x;

vec3 p = Positions[gid].xyz;
vec3 v = Velocities[gid].xyz;
vec3 pp = p + v * DT + 0.5 * DT * DT * G;
vec3 vp = v + G * DT;

if( IsInsideSphere( pp, SPHERE ) )
{
    vp = BounceSphere(p, v, SPHERE);
    pp = p + vp * DT + 0.5 * DT * DT * G;
}

Positions[gid].xyz = pp;
Velocities[gid].xyz = vp;

*/
